using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Server.Codegen;

[Generator]
public class ChangeTrackedObjectGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver) return;
        foreach (var registeredClass in receiver.ClassInfos)
        {
            var source = new StringBuilder();
            source.Append(
                $@"// <auto-generated/>
using System;
using Godot;
using Server.Core;
using Server.Util;

namespace {registeredClass.Namespace};

public partial class {registeredClass.Name}
{{");
            foreach (var variable in registeredClass.NameTypeKeypair)
            {
                var publicFormattedName = variable.Key.Substring(1, 1).ToUpper() + variable.Key.Substring(2);
                source.Append($@"

    public {variable.Value} {publicFormattedName}
    {{
        get => {variable.Key};
        set
        {{
            {variable.Key} = value;
            SimpleChangeTracker().TrackChange(""{publicFormattedName}"", value);
        }}
    }}");
            }
            source.Append($@"
    public override void TrackAllAsChanged()
    {{");
            source.Append($@"
        base.TrackAllAsChanged();");
            source.Append($@"
        var tracker = SimpleChangeTracker();");

            foreach (var variable in registeredClass.NameTypeKeypair)
            {
                var capitalizedName = char.ToUpper(variable.Key.First()) + variable.Key.Substring(1);
                source.Append($@"
        tracker.TrackChange(""{capitalizedName}"", {capitalizedName});");
            }

            source.Append($@"
    }}
}}");
            context.AddSource($"{registeredClass.Name}.g.cs", source.ToString());
        }
    }
}

public class SyntaxReceiver : ISyntaxReceiver
{
    public struct ClassInfo
    {
        public readonly string Name;
        public readonly string Namespace;
        public readonly Dictionary<string, string> NameTypeKeypair;

        public ClassInfo(string name, string classNamespace)
        {
            Name = name;
            Namespace = classNamespace;
            NameTypeKeypair = new Dictionary<string, string>();
        }
    }

    public List<ClassInfo> ClassInfos { get; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is not AttributeSyntax
            {
                Name: IdentifierNameSyntax { Identifier.Text: "GenerateTrackedProperties" }
            } attributeSyntax) return;
        if (attributeSyntax.Parent?.Parent is not ClassDeclarationSyntax classSyntax) return;

        foreach (var member in classSyntax.Members)
        {
            #nullable disable
            // fieldSyntax will never be null if TryParseFieldSyntax returns true
            if (TryParseFieldSyntax(member, out var fieldSyntax))
            {
                ProcessFieldSyntax(classSyntax, fieldSyntax);
            }
        }
    }

    private void ProcessFieldSyntax(BaseTypeDeclarationSyntax classSyntax, BaseFieldDeclarationSyntax fieldSyntax)
    {
        var type = fieldSyntax.Declaration.Type.GetFirstToken().Text;
        if (fieldSyntax.Declaration.Type is ArrayTypeSyntax)
        {
            type += "[]";
        }

        var name = fieldSyntax.Declaration.Variables[0].GetFirstToken().Text;
        if (ClassInfos.All(info => info.Name != classSyntax.Identifier.Text))
        {
            var namespaceText = "";
            if (classSyntax.Parent is FileScopedNamespaceDeclarationSyntax fileScopedNamespaceDeclarationSyntax)
            {
                namespaceText = fileScopedNamespaceDeclarationSyntax.Name.ToFullString();
            }

            if (namespaceText.Length != 0)
                ClassInfos.Add(new ClassInfo(classSyntax.Identifier.Text, namespaceText));
        }

        if (type == "IChangeTracker") return;
        ClassInfos.First(info => info.Name == classSyntax.Identifier.Text).NameTypeKeypair.Add(name, type);
    }

    #nullable enable
    private static bool TryParseFieldSyntax(MemberDeclarationSyntax member,
        out FieldDeclarationSyntax? fieldDeclarationSyntax)
    {
        if (member.Modifiers.Any(m => m.IsKind(SyntaxKind.StaticKeyword) || m.IsKind(SyntaxKind.ReadOnlyKeyword)))
        {
            fieldDeclarationSyntax = null;
            return false;
        }

        if (member is not FieldDeclarationSyntax fieldSyntax)
        {
            fieldDeclarationSyntax = null;
            return false;
        }

        if (member.DescendantNodes()
            .OfType<AttributeSyntax>()
            .Any(attribute => attribute.Name.ToString() == "TrackingIgnored"))
        {
            fieldDeclarationSyntax = null;
            return false;
        }

        fieldDeclarationSyntax = fieldSyntax;
        return true;
    }
}